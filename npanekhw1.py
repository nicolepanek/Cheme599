# -*- coding: utf-8 -*-
"""NPanekhw1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ektW3SZgEBig-Xl5zNCuY3uVkAtHadzI

## Problem 1

Import `scikit-image` and `matplotlib.pyplot`
"""

from skimage import data
import matplotlib.pyplot as plt

"""From the `sk.data` module, read in the `retina` image as the variable `im`."""

im = data.retina()

"""Use the `plt.imshow` command to display the image. Make the image larger and remove the axis labels."""

fig, ax = plt.subplots(figsize=(6,6))

ax.imshow(im)
ax.axis('off')

"""Oftentimes it is easier to do analyses on grayscale images. Find a function im `skimage` that converts the image to grayscale. Save the output as `im_gr`. Plot the image, making sure the color scheme is also grayscale."""

from skimage.color import rgb2gray

im_gr = rgb2gray(im)

fig, ax = plt.subplots(figsize = (6,6))

ax.imshow(im_gr, cmap = 'gray')
ax.axis('off')

"""# Problem 2

Read up in the `scikit-image` documentation and find two functions that are new to you. Try using them on the `im` or `im_gr` images you defined above.
"""

# Convert from RGB to HSV (Hue, Saturation, Value) to separate different areas of the image
from skimage.color import rgb2hsv 

im_hsv = rgb2hsv(im)
im_hue = im_hsv[:,:,0]
im_val = im_hsv[:,:,2]

fig, axes = plt.subplots(ncols=3, figsize=(8, 8))

axes[0].imshow(im)
axes[1].imshow(im_hue)
axes[2].imshow(im_val)

for ax in axes:
  ax.axis('off')

#Use the Canny filter to detect the edge for two values of sigma
from skimage import feature

#Compute the Canny edge 
im_edg1 = feature.canny(im_gr)
im_edg2 = feature.canny(im_gr, sigma=3)

fig, axes = plt.subplots(ncols=3, figsize=(8, 8))

axes[0].imshow(im_gr, cmap='gray')
axes[1].imshow(im_edg1, cmap='binary')
axes[2].imshow(im_edg2, cmap='binary')

for ax in axes:
  ax.axis('off')

"""# Problem 3

Identify an image dataset that you have access to, either from your research or from an open-source dataset, that you would be interested in analyzing for your course project.

Verify that you can import one of the image(s) into your Jupyter notebook with the command `plt.imread`. If the image has a special file type, you may need to read up on the internet for the proper way to import the image using Python.
"""

from google.colab import drive

drive.mount('/content/drive', force_remount=True)

lilyslice = plt.imread('/content/drive/MyDrive/lilyslice.jpeg')
plt.imshow(lilyslice)

lilymask = plt.imread('/content/drive/MyDrive/lilymask.jpeg')
plt.imshow(lilymask)

"""Using Markdown, describe the image dataset below. Important things to include would be a description of what is displayed in the image, what equipment was used to collect the data, and any important settings used when collecting the data, and the size of the image dataset.

*We have two datasets: the first includes 50 images of tiger lilies sliced horizontally across the bud taken with a normal camera; the second includes hand-traced masks of the lily tepals made in photoshop.*

Write a short pitch of a potential project you could perform over the course of the quarter using this image dataset. This should include:

* A statement of the problem or question to be answered
* A proposed solution
* Tools to be used from `scikit-image` or elsewhere

*The physcial process of tiger lily blooming can be studied and predicted based on a bud's outer petals. This process requires making a mask of each tepal (outer part of the flower) as shown above and measuring each tepal's thickness and length. This is a time consuming process that we hope to improve by creating a script that autimatically measures and plots the thickness vs. length of the tepals for each slice. Optimistically, our script will accurately create masks of a lily slice from the origional image set. We anticipate using the scikit-image find_contour and Erosion tools to find the edges of a lily mask. We may also use the scikit-image skeletonize tool and tangent lines at regular intervals to measure the tepal thickness, but will need to do some more digging to determine what the best tool will be.*
"""